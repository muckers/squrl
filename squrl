#!/bin/sh
#
# squrl - URL shortener CLI for squrl API
# Usage: squrl <url> [options]
#
# Options:
#   -t, --ttl <hours>      Set expiration time in hours (1-87600)
#   -s, --staging          Use staging environment
#   -e, --endpoint <url>   Override API endpoint
#   -j, --json             Return full JSON response
#   -h, --help             Show help message

set -e

# Default values
DEFAULT_ENDPOINT="https://squrl.pub"
# Temporary: Using API Gateway directly for staging until CloudFront POST is configured
STAGING_ENDPOINT="https://q3lq9c9i4e.execute-api.us-east-1.amazonaws.com"
API_ENDPOINT="${SQURL_API_ENDPOINT:-$DEFAULT_ENDPOINT}"
TTL_HOURS=""
JSON_OUTPUT=0
URL=""

# Colors for output (disable if not terminal)
if [ -t 1 ]; then
    RED='\033[0;31m'
    GREEN='\033[0;32m'
    YELLOW='\033[1;33m'
    NC='\033[0m' # No Color
else
    RED=''
    GREEN=''
    YELLOW=''
    NC=''
fi

# Function to show usage
show_usage() {
    cat << EOF
Usage: $(basename "$0") <url> [options]

Shorten a URL using the squrl API

Options:
  -t, --ttl <hours>      Set expiration time in hours (1-87600)
  -s, --staging          Use staging environment (staging.squrl.pub)
  -e, --endpoint <url>   Override API endpoint
  -j, --json             Return full JSON response
  -h, --help             Show this help message

Environment Variables:
  SQURL_API_ENDPOINT     Override default API endpoint

Examples:
  # Basic usage (uses squrl.pub)
  $(basename "$0") https://example.com

  # Use staging environment
  $(basename "$0") https://example.com --staging

  # With TTL (expire in 24 hours)
  $(basename "$0") https://example.com -t 24

  # Get full JSON response
  $(basename "$0") https://example.com -j

EOF
}

# Function to print error and exit
error() {
    printf "${RED}Error: %s${NC}\n" "$1" >&2
    exit 1
}

# Parse command line arguments
while [ $# -gt 0 ]; do
    case "$1" in
        -h|--help)
            show_usage
            exit 0
            ;;
        -s|--staging)
            API_ENDPOINT="$STAGING_ENDPOINT"
            shift
            ;;
        -t|--ttl)
            shift
            if [ $# -eq 0 ]; then
                error "TTL requires an argument"
            fi
            TTL_HOURS="$1"
            shift
            ;;
        -e|--endpoint)
            shift
            if [ $# -eq 0 ]; then
                error "Endpoint requires an argument"
            fi
            API_ENDPOINT="$1"
            shift
            ;;
        -j|--json)
            JSON_OUTPUT=1
            shift
            ;;
        -*)
            error "Unknown option: $1"
            ;;
        *)
            if [ -z "$URL" ]; then
                URL="$1"
            else
                error "Multiple URLs provided. Only one URL is allowed."
            fi
            shift
            ;;
    esac
done

# Check if URL was provided
if [ -z "$URL" ]; then
    printf "${RED}Error: No URL provided${NC}\n" >&2
    show_usage
    exit 1
fi

# Add https:// if no protocol is provided
case "$URL" in
    http://*|https://*)
        # URL already has a protocol
        ;;
    //*)
        # Protocol-relative URL, prepend https:
        URL="https:$URL"
        ;;
    *)
        # No protocol, prepend https://
        URL="https://$URL"
        ;;
esac

# Build JSON payload
build_json_payload() {
    printf '{"original_url":"%s"' "$URL"

    if [ -n "$TTL_HOURS" ]; then
        printf ', "ttl_hours":%s' "$TTL_HOURS"
    fi

    printf '}'
}

# Check for required tools
command -v curl >/dev/null 2>&1 || error "curl is required but not installed"
command -v jq >/dev/null 2>&1 || error "jq is required but not installed"

# Build the JSON payload
PAYLOAD=$(build_json_payload)

# Determine the correct API path based on endpoint
if [ "$API_ENDPOINT" = "$STAGING_ENDPOINT" ]; then
    # For staging (API Gateway direct), use /v1/create
    API_PATH="/v1/create"
else
    # For production (CloudFront), use /create (CloudFront adds /v1 via origin_path)
    API_PATH="/create"
fi

# Make the API request
RESPONSE=$(curl -s -w "\n%{http_code}" -X POST \
    -H "Content-Type: application/json" \
    -d "$PAYLOAD" \
    "${API_ENDPOINT}${API_PATH}" 2>/dev/null) || error "Failed to connect to API"

# Split response body and HTTP status code
HTTP_CODE=$(printf "%s" "$RESPONSE" | tail -n1)
BODY=$(printf "%s" "$RESPONSE" | sed '$d')

# Check HTTP status code
if [ "$HTTP_CODE" != "200" ]; then
    ERROR_MSG=$(printf "%s" "$BODY" | jq -r '.message // .error // "Unknown error"' 2>/dev/null || printf "%s" "$BODY")
    error "API request failed (HTTP $HTTP_CODE): $ERROR_MSG"
fi

# Parse and display the response
if [ "$JSON_OUTPUT" -eq 1 ]; then
    # Output full JSON response
    printf "%s" "$BODY" | jq '.' 2>/dev/null || printf "%s\n" "$BODY"
else
    # Extract just the short URL
    SHORT_URL=$(printf "%s" "$BODY" | jq -r '.short_url // empty' 2>/dev/null)

    if [ -z "$SHORT_URL" ]; then
        # Fallback: construct URL from short_code if short_url is not in response
        SHORT_CODE=$(printf "%s" "$BODY" | jq -r '.short_code // empty' 2>/dev/null)
        if [ -n "$SHORT_CODE" ]; then
            # Extract base URL from API endpoint
            BASE_URL=$(printf "%s" "$API_ENDPOINT" | sed 's|/v[0-9]*$||')
            SHORT_URL="${BASE_URL}/${SHORT_CODE}"
        else
            error "Unable to extract short URL from response"
        fi
    fi

    printf "${GREEN}%s${NC}\n" "$SHORT_URL"
fi
